var background=function(){"use strict";var F,U;const n=(U=(F=globalThis.browser)==null?void 0:F.runtime)!=null&&U.id?globalThis.browser:globalThis.chrome;function L(t){return t==null||typeof t=="function"?{main:t}:t}let l="NA",g="NA";const I=3e4;async function A(){return new Promise(t=>{try{n.storage.local.get(["userId","session-token"],function(e){if(chrome.runtime.lastError){console.error("SW: Error accessing storage:",chrome.runtime.lastError),l="NA",g="NA",t();return}e.userId!==void 0&&e.userId!==null&&e.userId!==""?(l=e.userId,console.log("SW: Loaded userId from storage")):(l="NA",console.log("SW: No userId found in storage")),e["session-token"]!==void 0&&e["session-token"]!==null&&e["session-token"]!==""?(g=e["session-token"],console.log("SW: Loaded session token from storage")):(g="NA",console.log("SW: No session token found in storage")),t()})}catch(e){console.error("SW: Critical error accessing storage:",e),l="NA",g="NA",t()}})}async function p(){return new Promise(t=>{try{n.storage.local.get(["userId","session-token"],function(e){if(chrome.runtime.lastError){console.error("SW: Error accessing storage during reload:",chrome.runtime.lastError),l="NA",g="NA",t();return}e.userId!==void 0&&e.userId!==null&&e.userId!==""?(l=e.userId,console.log("SW: Reloaded userId from storage")):(l="NA",console.log("SW: No userId in storage during reload")),e["session-token"]!==void 0&&e["session-token"]!==null&&e["session-token"]!==""?(g=e["session-token"],console.log("SW: Reloaded session token from storage")):(g="NA",console.log("SW: No session token in storage during reload")),t()})}catch(e){console.error("SW: Critical error during storage reload:",e),l="NA",g="NA",t()}})}async function W(t,e){if(!t||t.status!==404)return!1;try{const s=await t.clone().json();if(((s==null?void 0:s.message)||(s==null?void 0:s.error)||"").toLowerCase().includes("user not found"))return console.log(`SW: User not found during ${e} - clearing all user data`),await E(),!0}catch{}return!1}async function E(){return console.log("SW: Clearing all user data"),new Promise(t=>{n.storage.local.remove(["userId","session-token","user-email","lastPingTime","lastPingStatus","lastPingError","lastPingData","userPoints","lastPointsFetchTime","lastPointsFetchStatus","lastPointsFetchError"],()=>{l="NA",g="NA",console.log("SW: User data and session token cleared"),n.runtime.sendMessage({type:"FORCE_LOGOUT"}).catch(()=>{}),t()})})}async function T(t,e={}){if(await A(),!g||g==="NA")return console.error("SW: No session token available for API call. User needs to login via popup."),null;console.log("SW: Using session token (JWT) for background API call");const r={"Content-Type":"application/json",Authorization:`Bearer ${g}`,...e.headers},s={...e,headers:r};try{const o=await b(t,s);return o&&o.status===401?(console.log("SW: 401 error with session token - token expired, clearing user data"),await E(),null):o}catch(o){return console.error("SW: API request failed:",o),null}}async function b(t,e={}){const o=new AbortController,c=setTimeout(()=>o.abort(),I);e.signal=o.signal;for(let i=1;i<=5;i++)try{const a=await fetch(t,e);if(clearTimeout(c),a)return a}catch(a){if(clearTimeout(c),a.name==="AbortError"?console.log(`Service Worker: Request timeout on attempt ${i}`):a.name==="TypeError"&&a.message.includes("Failed to fetch")&&console.log(`Service Worker: Network error on attempt ${i}`),i===5)throw a;console.log(`Service Worker: Attempt ${i} failed. Retrying in 3 seconds...`),await new Promise(f=>setTimeout(f,3e3));const w=new AbortController;setTimeout(()=>w.abort(),I),e.signal=w.signal}}const u={apiUrl:"https://api.dawninternet.com",dashboardUrl:"https://dashboard.dawninternet.com",isDevelopment:!1,privyAppId:"cmfb724md0057la0bs4tg0vf1",pingIntervalMs:parseInt("1200000"),pointsPerPong:20};let d=!1;async function k(){if(d){console.log("SW: Ping already in progress, skipping duplicate request");return}d=!0;const e=(await new Promise(i=>{n.storage.local.get(["lastPingTime"],a=>{i(a)})})).lastPingTime||0,s=Date.now()-e,o=u.pingIntervalMs,c=5e3;if(s<o-c){console.log(`SW: Skipping ping - only ${Math.round(s/1e3)}s since last ping (need ${(o-c)/1e3}s)`),d=!1;return}console.log(`SW: Ping started at ${new Date().toISOString()}`);try{if(await p(),l==="NA"||!l){n.storage.local.set({lastPingTime:Date.now(),lastPingStatus:"failed",lastPingError:"No user ID available"}),console.log("SW: No user ID available, skipping ping"),n.runtime.sendMessage({type:"FORCE_LOGOUT"}).catch(()=>{}),d=!1;return}try{const i={user_id:l,extension_id:n.runtime.id,timestamp:new Date().toISOString()},a=await T(`${u.apiUrl}/ping?role=extension`,{method:"POST",body:JSON.stringify(i)});if(await W(a,"ping")){d=!1;return}const f=await(a==null?void 0:a.json());if(a&&a.ok)console.log("SW: Ping ✓ - Pong received"),n.storage.local.set({lastPingTime:Date.now(),lastPingStatus:"success",lastPingData:f}),await M(),n.runtime.sendMessage({type:"PING_SUCCESS",timestamp:Date.now(),data:f}).catch(()=>{});else{const m=f;throw new Error((m==null?void 0:m.message)||(m==null?void 0:m.error)||"Ping failed")}}catch(i){console.error("SW: Ping ✗",i.message),n.storage.local.set({lastPingTime:Date.now(),lastPingStatus:"failed",lastPingError:i.message}),n.runtime.sendMessage({type:"PING_ERROR",timestamp:Date.now(),error:i.message}).catch(()=>{})}}catch(i){console.error("SW: Ping exception",i)}finally{d=!1}}async function R(){console.log("SW: checkForImmediatePingAfterLogin - Starting check");try{const t=await new Promise(s=>{n.storage.local.get(["userPoints","lastPingTime"],o=>{s(o)})}),e=t.userPoints,r=t.lastPingTime||0;if(console.log("SW: checkForImmediatePingAfterLogin - userPoints:",e),console.log("SW: checkForImmediatePingAfterLogin - lastPingTime:",r),e&&e.points===0){console.log("SW: checkForImmediatePingAfterLogin - User has 0 points, checking timing");const o=Date.now()-r,c=u.pingIntervalMs;if(console.log("SW: checkForImmediatePingAfterLogin - timeSinceLastPing:",o),console.log("SW: checkForImmediatePingAfterLogin - pingIntervalMs:",c),console.log("SW: checkForImmediatePingAfterLogin - interval check:",o>=c),o>=c){console.log("SW: User has 0 points, sending immediate ping after login"),await k();const i=u.pingIntervalMs/6e4;console.log("SW: Resetting ping alarm to synchronize with immediate ping"),n.alarms.clear("ping",()=>{n.alarms.create("ping",{periodInMinutes:i,when:Date.now()+i*6e4}),console.log("SW: Ping alarm reset successfully")})}else console.log("SW: User has 0 points but recent ping exists, respecting interval")}else e?console.log("SW: checkForImmediatePingAfterLogin - User has",e.points,"points, no immediate ping needed"):console.log("SW: checkForImmediatePingAfterLogin - No userPoints data found")}catch(t){console.error("SW: Error in checkForImmediatePingAfterLogin:",t)}}async function M(){try{const e=(await new Promise(s=>{n.storage.local.get(["userPoints"],o=>{s(o)})})).userPoints;if(!e){console.log("SW: No current points data found, skipping increment");return}const r={...e,points:e.points+u.pointsPerPong,updated_at:new Date().toISOString()};console.log(`SW: Points incremented by ${u.pointsPerPong}: ${e.points} → ${r.points}`),n.storage.local.set({userPoints:r,lastPointsFetchTime:Date.now(),lastPointsFetchStatus:"success"}),n.runtime.sendMessage({type:"POINTS_FETCH_SUCCESS",timestamp:Date.now(),data:r}).catch(()=>{})}catch(t){console.error("SW: Error incrementing points after pong:",t)}}async function P(){try{if(await p(),l==="NA"||!l){console.log("SW: No user ID available, skipping points fetch"),n.runtime.sendMessage({type:"FORCE_LOGOUT"}).catch(()=>{});return}try{const t=`${u.apiUrl}/point?user_id=${l}`,e=await T(t,{method:"GET"});if(await W(e,"points fetch"))return;const s=await(e==null?void 0:e.json());if(e&&e.ok){const o=s.points+s.referral_points;console.log("SW: Points ✓",`points: ${s.points} + referral_points: ${s.referral_points} = totalPoints: ${o}`),n.storage.local.set({userPoints:s,lastPointsFetchTime:Date.now(),lastPointsFetchStatus:"success"}),n.runtime.sendMessage({type:"POINTS_FETCH_SUCCESS",timestamp:Date.now(),data:s}).catch(()=>{})}else{const o=s;throw new Error((o==null?void 0:o.message)||(o==null?void 0:o.error)||"Points fetch failed")}}catch(t){console.error("SW: Points ✗",t.message),n.storage.local.set({lastPointsFetchTime:Date.now(),lastPointsFetchStatus:"failed",lastPointsFetchError:t.message}),n.runtime.sendMessage({type:"POINTS_FETCH_ERROR",timestamp:Date.now(),error:t.message}).catch(()=>{})}}catch(t){console.error("SW: Points exception",t)}}async function C(){console.log("SW: User login successful, checking for immediate ping");try{await P(),await R()}catch(t){console.error("SW: Error in handleUserLoginSuccess:",t)}}const y=u.pingIntervalMs/6e4,N=1,_=10;function D(){n.alarms.getAll(t=>{const e=t.find(o=>o.name==="ping"),r=t.find(o=>o.name==="swKeepAlive"),s=t.find(o=>o.name==="fetchPoints");e||n.alarms.create("ping",{periodInMinutes:y}),r||n.alarms.create("swKeepAlive",{periodInMinutes:N}),s||n.alarms.create("fetchPoints",{periodInMinutes:_})}),n.runtime.getPlatformInfo(()=>{})}function O(){n.alarms.clearAll(()=>{n.alarms.create("ping",{periodInMinutes:y}),n.alarms.create("swKeepAlive",{periodInMinutes:N}),n.alarms.create("fetchPoints",{periodInMinutes:_})})}async function $(){return new Promise(t=>{n.storage.local.get(["sw-initialized"],e=>{t(e["sw-initialized"]||!1)})})}async function v(t){return new Promise(e=>{n.storage.local.set({"sw-initialized":t},()=>{console.log(`SW: Initialization state set to ${t}`),e()})})}const z=L(()=>{console.log("SW: Initialized");async function t(){if(await $()){console.log("SW: Already initialized, skipping initialization");return}console.log("SW: Initializing"),O(),await A(),console.log("SW: Fetching user points on Initialization before login"),P(),await v(!0)}t(),self.addEventListener("activate",e=>{console.log("SW: Activated"),e.waitUntil&&e.waitUntil(t())}),n.alarms.onAlarm.addListener(e=>{e.name==="ping"?k():e.name==="swKeepAlive"?D():e.name==="fetchPoints"&&P()}),n.runtime.onMessage.addListener((e,r,s)=>{var o;try{if(!((o=chrome==null?void 0:chrome.runtime)!=null&&o.id))return console.warn("SW: Extension context invalidated, ignoring message"),!1}catch(c){return console.warn("SW: Extension context check failed:",c),!1}if(e.action==="ping")s({status:"ping_managed_by_alarm"});else if(e.action==="fetchPoints")P(),s({status:"points_fetch_initiated"});else{if(e.type==="GET_PING_STATUS")return n.storage.local.get(["lastPingTime","lastPingStatus","lastPingError","lastPingData"],c=>{s(c)}),!0;if(e.type==="GET_POINTS_STATUS")return n.storage.local.get(["userPoints","lastPointsFetchTime","lastPointsFetchStatus","lastPointsFetchError"],c=>{s(c)}),!0;e.type==="RESTART_SERVICE"?(v(!1),t(),s({status:"restarted"})):e.type==="USER_LOGIN_SUCCESS"?(C(),s({status:"login_ping_check_initiated"})):e.type==="RELOAD_USER_DATA"&&(console.log("SW: Force reloading user data due to token update"),p(),s({status:"user_data_reloaded"}))}return!0}),n.runtime.onInstalled.addListener(()=>{console.log("SW: Extension installed/updated"),t()}),n.runtime.onStartup.addListener(()=>{console.log("SW: Chrome started"),t()}),n.storage.onChanged.addListener((e,r)=>{var s;try{if(!((s=chrome==null?void 0:chrome.runtime)!=null&&s.id)){console.warn("SW: Extension context invalidated, ignoring storage change");return}r==="local"&&e["session-token"]&&(console.log("SW: Session token updated in storage, reloading user data"),p())}catch(o){console.warn("SW: Error handling storage change:",o)}})});function H(){}function S(t,...e){}const x={debug:(...t)=>S(console.debug,...t),log:(...t)=>S(console.log,...t),warn:(...t)=>S(console.warn,...t),error:(...t)=>S(console.error,...t)};let h;try{h=z.main(),h instanceof Promise&&console.warn("The background's main() function return a promise, but it must be synchronous")}catch(t){throw x.error("The background crashed on startup!"),t}return h}();
background;
